
# 数通/计网知识

## 基于TCP/IP模型的数据通信过程

### TCP/IP 模型


数据网络：一个由各种设备搭建起来的一张网，实现不同节点之间的数据通信

- 常见设备：路由器、交换机、防火墙、负载均衡器、IDS/IPS、VPN等等

TCP/IP模型每层对应的协议：

![2023-03-28-15-15-34](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-28-15-15-34.png)

### TCP/IP 协议栈

![2023-04-20-20-08-32](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-04-20-20-08-32.png)

### 数据通信过程


![2023-03-28-15-16-27](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-28-15-16-27.png)

整个过程：

1）原始数据
<img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-28-15-18-06.png" alt="2023-03-28-15-18-06" style="zoom:67%;" />

2）加上TCP头
<img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-28-15-18-13.png" alt="2023-03-28-15-18-13" style="zoom:67%;" />

3）加上 IP头
<img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-28-15-18-53.png" alt="2023-03-28-15-18-53" style="zoom:67%;" />

4）
<img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-28-15-19-34.png" alt="2023-03-28-15-19-34" style="zoom:67%;" />

- 源MAC地址是：PC的网卡MAC
- 目的MAC：因为不在同一个网段，所以需要借助自己的网关把数据包转发出去，所以这里是网关MAC地址
  - 初始情况下，PC没有网关的MAC，所以发送一个ARP广播去请求，R1的GE0/0/0口会收到这个ARP请求并且回送ARP响应
- 以太网数据帧头的类型字段是0x0800这个值，表示这个数据帧头后面封装的是一个IP包

5）
<img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-28-15-23-31.png" alt="2023-03-28-15-23-31" style="zoom:67%;" />

- 变成一堆101110101从网线传到了路由器R1上

6）
<img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-28-15-24-05.png" alt="2023-03-28-15-24-05" style="zoom:67%;" />

- 路由器R1在收到这一串的1010后，先将他们还原成数据帧
- 然后会采用相应的机制检查一下数据帧在传输过程中是否有损坏，如果没有损坏，那么就瞅瞅数据帧头部中的目的MAC地址，看看目的MAC地址是不是我收到这个数据帧的GE0/0/0口的MAC，结果发现正好是自己的MAC，它很高兴，觉得这个数据帧是给它的，它查看数据帧头部的类型字段，发现是0x0800，于是它知道里头装的是一个IP包，接着它将以太网数据帧头剥去或者说解封装，然后将里面的数据移交给上层IP协议继续处理

7）
<img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-28-15-25-16.png" alt="2023-03-28-15-25-16" style="zoom:67%;" />

- R1的IP协议栈接着处理这个报文
- 它会先校验一下数据在传输过程中，IP头有没有受损，如果没有，它就查看IP头中的目的IP地址字段，结果发现目的IP地址为192.168.2.1，并不是自己的IP地址 – 原来这个数据包是发给别人的，于是它开始拿着目的地址192.168.2.1到自己的地图（路由表）里去查，看看有没有到192.168.2.1这个目的地去的路径，结果发现有，并且这个路由条目指示它把数据包从从GE0/0/1口送出去交给192.168.12.2这个IP。于是它不再继续拆开IP头看包裹里头的东东了，而是乖乖的将IP数据包往下交还给数据链路层去处理

8）
<img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-28-15-27-40.png" alt="2023-03-28-15-27-40" style="zoom:67%;" />

- 数据链路层继续处理上层下来的IP包，它为这个IP包封装上一个新的以太网帧头
- 帧头中源MAC地址为R1的GE0/0/1口的MAC：0018-0011-0002
- 目的MAC是这个数据包即将交给的下一跳路由器192.168.12.2对应的MAC，当然初始情况下R1是不知道这个MAC的，因此又是一轮ARP广播并最终拿到这个MAC：0018-0022-0001，于是它将这个值填写在目的MAC字段中
- 完成新的数据帧头的封装后，R1把这个数据帧变成1010101通过电气信号传递给R2


9）

- R2收到这些10101后，同样的，还是先将其还原成帧，然后查看帧头，发现目的MAC填写的就是自己接口的MAC，并且帧头中类型字段写的是0x0800（指示上层协议是IP，也就是数据帧头内封装的是一个IP包），于是将数据帧头剥去，将里头的IP数据包交给IP协议去处理

10）
<img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-28-15-30-44.png" alt="2023-03-28-15-30-44" style="zoom:67%;" />

- R2的IP协议在处理过程中发现，目的IP地址并非本路由器的IP，于是它知道，这个数据包不是发送给自己的，它拿着目的IP地址192.168.2.1在路由表中去查，结果发现，R2的GE0/0/1口就连接着192.168.2.0/24网络，原来家门口就是了，于是它将这个IP包交还给下层协议去处理

11）
<img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-28-15-34-19.png" alt="2023-03-28-15-34-19" style="zoom:67%;" />

- R2的数据链路层又是重新封装成帧，R2为这个IP包封装上一个新的数据帧头部
- 帧头中，源 MAC 为 R2 的 GE0/0/1 口的 MAC，目的 MAC 为 192.168.2.1 这个 IP 地址对应的 MAC，如果 ARP 表里有 192.168.2.1 对应的 MAC，则直接将 MAC 地址写入目的 MAC 中，如果没有，则发 ARP 去请求
- 另外类型字段依然填写 0x0800
- 最终，R2 将这个数据帧传给了 Server

12）
<img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-28-15-38-40.png" alt="2023-03-28-15-38-40" style="zoom:67%;" />

- 数据帧到了 Server
- Server 首先是将 101010 这些比特流还原成帧，然后做校验看看帧头是否损坏，如果没有，则查看数据帧的目的 MAC，结果发现就是自己的网卡 MAC，于是查看类型字段，发现是 0x0800，知道这里头装的是一个 IP 包，于是将帧头剥去，将内层的 IP 数据包交给上层协议 IP 去处理
- IP 收到这个数据包之后，首先依然是查看 IP 包头是否损坏，如果没有，则查看目的 IP 地址，发现目的 IP 地址是 192.168.2.1 正是自己的网卡 IP，于是它知道，这个 IP 包是发给自己的，因此继续查看 IP 包头中的协议字段，发现协议字段填写的是 6 这个值，原来这个 IP 包头后面封装的是一个 TCP 的数据，因此将 IP 包头剥去，将里头的 TCP 数据交给上层的 TCP 协议去处理
- TCP 在处理这个数据的时候，查看 TCP 头部的目的端口号，发现目的端口号是 80，而本地的 TCP 80 端口是开放的，开放给 HTTP 应用了，接着它将 TCP 头部剥去，交给 HTTP 应用
- 从 PC 发送出来的 HTTP 应用数据，终于到达了目的地 Server 的 HTTP 应用的手中



## 传输层协议 TCP/UDP



### TCP/UDP 报文

- UDP

<img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-04-20-20-15-00.png" alt="2023-04-20-20-15-00" style="zoom: 67%;" />


- TCP

<img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-04-20-20-15-13.png" alt="2023-04-20-20-15-13" style="zoom:67%;" />



下面是打印出的十六进制格式的**UDP 首部**

``` 
06 32 00 0D 00 1C E2 17

a. 源端口号是什么？
b. 目的端口号是什么？
c. 用户数据报的总长度是什么？
d. 数据的总长度是什么？
e. 该分组是从客户发送到服务器还是反过来？

解：
a. 源端口号为1586（0x0632）。
b. 目的端口号13（0x000D）。
c. 用户数据报的总长度是28（0x001C）字节。
d. 数据的总长度是20 字节（28 – 8 = 20）。
e. 从客户发送到服务器。（因为源端口为1586，不在熟知端口0~1023 中）
```



### TCP 连接


- TCP 连接

  - 三次握手


<img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-04-20-20-17-25.png" alt="2023-04-20-20-17-25" style="zoom: 33%;" />


- 断开 TCP 连接

  - 四次挥手


<img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-04-20-20-17-44.png" alt="2023-04-20-20-17-44" style="zoom: 33%;" />








## 网络层协议



### IP 协议



#### 基础概念

- IP 协议是 TCP/IP 协议族中最为核心的协议
- IP 协议**把上层数据报封装成 IP 数据报后进行传输**，如果 IP 数据报太大，还要对数据报进行分片后再传输，到了目的地址处再进行组装还原，以适应不同物理网络对一次所能传输数据大小的要求

- 特点：
  - **不能保证 IP 数据报能成功地到达目的地**。IP 协议仅提供传输服务，如果发生某种错误时，如某个路由器暂时用完了缓冲区，IP 有一个简单的错误处理算法：丢弃该数据报，然后发送 ICMP 消息报给信源端。任何要求的可靠性必须由上层协议来提供（如TCP协议）。
  - IP 协议并不维护任何关于后续数据报的状态信息，每个数据报的处理是**相互独立**的。这也说明，IP数据报可以不按发送顺序接收。例如，如果一信源向相同的信宿发送两个连续的数据报（先是 A，然后是 B），每个数据报都是独立地进行路由选择，可能选择不同的路线，因此 B 可能在 A 之前先到达。
  - 通信双方不同步传输数据的状态信息，无法处理乱序和重复的 IP 数据报；IP 数据报提供了标识字段用来唯一标识 IP 数据报，用来处理 IP 分片和重组，不指示接收顺序。





#### IP 报文

IPv4 报文结构：

![在这里插入图片描述](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pmo5pum6Im-57Gz,size_20,color_FFFFFF,t_70,g_se,x_16.png)

- 版本（Version）

  - 占用 4 bit
  - 标识目前采用的IP协议的版本号，一般取值为 0100（IPv4）和 0110（IPv6）

- 首部长度（Header Length）

  - IP 报头长度
  - 占用 4 bit，由于在 IP 报头中有变长的可选部分，为了能多表示一些长度，因此采用 4 字节（32 bit）为本字段数值的单位，比如，4 bit 最大能表示为 1111，即 15，单位是 4 字节，因此最多能表示的长度为 15×4=60 字节

- 服务类型（Type of Service，TOS）

  - 占用 8 bit

  - 可用 PPP、D、T、R、C、0 这 8 个字符来表示，其中，PPP定义了数据报的优先级，取值越大表示数据越重要，取值如下表所示：

    | ppp 取值 | 含 义                            |
    | -------- | -------------------------------- |
    | 000      | 普通（Routine）                  |
    | 001      | 优先（Priority）                 |
    | 010      | 立即（Immediate）                |
    | 011      | 闪速（Flash）                    |
    | 100      | 疾速（Flash Override）           |
    | 101      | 关键（Critic）                   |
    | 110      | 网间控制（Internetwork Control） |
    | 111      | 网络控制（Network Control）      |

  - D：时延，0 表示普通，1表示延迟尽量小；

  - T：吞吐量，0 表示普通，1表示流量尽量大；

  - R：可靠性，0 表示普通，1表示可靠性尽量大；

  - C：传输成本，0 表示普通，1表示成本尽量小；

  - 0：这是最后一位，被保留，恒定为 0；

- 总长度

  - 占用 16 bit
  - 该字段表示以字节为单位的 IP 数据报的总长度（包括 IP 报头部分和 IP 数据部分）。如果该字段全为 1，就是最大长度了，即 216-1= 65535字节≈63.9990234375KB，有些教程上写最大是 64KB，其实是达不到的，最大长度只能是 65535 字节，而不是 65536 字节。

- 标识

  - 在协议栈中保持着一个计数器，每产生一个数据报，计数器就加 1，并将此值赋给标识字段。

  - 注意这个“标识符”并不是序号，IP 是无连接服务，数据报不存在按序接收的问题。当 IP 数据报由于长度超过网络的 MTU（Maximum Transmission Unit，最大传输单元）而必须分片（把一个大的网络数据报拆分成一个个小的数据报）时，这个标识字段的值就被复制到所有的小分片的标识字段中。相同的标识字段的值使得分片后的各数据报片最后能正确地重装成为原来的大数据报。

  - 该字段占用 16 bit。

    ```markdown
    分片（Fragmentation）:
    1. IP 协议在传输数据报时，将数据报分为若干分片（小数据报）后进行传输，并在目的系统中进行重组
    2. 物理网络一次传送的数据是有最大长度的，因此网络层的下层（数据链路层）的传输单元（数据帧）也有一个最大长度，这个最大长度值就是 MTU，每一种物理网络都会规定链路层数据帧的最大长度，比如以太网的 MTU 为 1500 字节
    3. IP 协议在传输数据报时，若IP数据报加上数据帧头部后长度大于 MTU，则将数据报切分成若干分片后再进行传输，并在目标系统中进行重组。IP 分片既可能在源端主机进行，也可能发生在中间的路由器处，因为不同网络的 MTU 是不一样的，而传输的整个过程可能会经过不同的物理网络。如果传输路径上的某个网络的 MTU 比源端网络的 MTU 要小，路由器就可能对 IP 数据报再次进行分片。分片数据的重组只会发生在目的端的 IP 层。
    ```

- 标志（Flags）

  - 该字段占用 3 bit
  - 该字段最高位不使用
  - 第二位称 DF（Don't Fragment）位，DF 位设为 1 时表明路由器不对该上层数据报分片。如果一个上层数据报无法在不分段的情况下进行转发，则路由器会丢弃该上层数据报并返回一个错误信息
  - 最低位称 MF（More Fragments）位，为 1 时说明这个 IP 数据报是分片的，并且后续还有数据报；为 0 时说明这个 IP 数据报是分片的，但已经是最后一个分片了。

- 片偏移

  - 该字段的含义是某个分片在原 IP 数据报中的相对位置
  - 第一个分片的偏移量为 0。片偏移以 8 个字节为偏移单位。这样，每个分片的长度一定是 8 字节（64 位）的整数倍。
  - 该字段占 13 bit。

- 生存时间（TTL，Time to Live，也称存活时间）

  - 表示数据报到达目标地址之前的路由跳数。
  - TTL 是由发送端主机设置的一个计数器，每经过一个路由节点就减 1，减到为 0 时，路由就丢弃该数据报，向源端发送 ICMP 差错报文。
  - 这个字段的主要作用是防止数据报不断在 IP 互联网络上循环转发。该字段占 8 bit。

- 协议

  - 该字段用来标识数据部分所使用的协议，比如取值1表示 ICMP、取值 2 表示 IGMP、取值 6 表示 TCP、取值 17 表示 UDP、取值 88 表示 IGRP、取值 89 表示 OSPF。
  - 该字段占 8 bit。

- 首部校验和（Header Checksum）

  - 该字段用于对 IP 头部的正确性检测，但不包含数据部分。由于每个路由器会改变 TTL 的值，所以路由器会为每个通过的数据报重新计算首部校验和。
  - 该字段占 16 bit。

- 源地址和目标地址

  - 用于标识这个 IP 数据报的起源和目标 IP 地址。
  - 值得注意的是，除非使用 NAT（网络地址转换），否则整个传输的过程中，这两个地址不会改变。
  - 这两个地段都占用 32 bit。

- 选项（可选）

  - 这是一个可变长的字段。该字段属于可选项，主要是给一些特殊的情况使用，最大长度是 40 字节。

- 填充（Padding）

  - 由于 IP 报头长度这个字段的单位为 32 bit，所以 IP 报头的长度必须为 32bit 的整数倍。因此，在可选项后面，IP 协议会填充若干个 0，以达到 32bit 的整数倍。





#### IP 地址




1. 定义

- **IP地址**在网络中用于**标识一个节点（或者网络设备的接口）**
- IP网络中数据包的寻址是基于IP地址来进行的，因此IP地址就像是现实生活中的地址
- IP协议定义了数据分组的格式，也定义了数据分组寻址的方式
  - 目前我们在业务环境中常见的IP主要是两个版本：**32 位的 IPv4 和 128 位的 IPv6**（后者是为了解决前者不够用的问题而产生的）
  - 而现阶段网络主体仍然是IPv4，但是在可预见的未来，会逐渐向IPv6过渡
- 一个IPv4地址有32位（二进制）
  - 十进制表示，比如 192.168.0.1
  - 二进制表示，比如 11000000.10101000.00000000.00000001




2. 十进制和二进制的转换

![2023-03-28-15-42-01](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-28-15-42-01.png)



3. IP地址的分类

IPv4地址的空间从0.0.0.0 一直到 255.255.255.255，这么庞大的空间，如果不加以区分和规划，势必不便于统筹管理。因此我们对IPv4地址空间进行类别上的划分，一共有五类：

![2023-03-28-15-42-51](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-28-15-42-51.png)

- A类：第一个八位组首位恒定为0
  - 1.0.0.0 - 127.255.255.255
  - 一个组 网络位 + 三个组 主机位
  - 默认掩码：255.0.0.0 或者 /8
  - 其中 127.0.0.0/8 作为本地回环使用
  - 这类地址适用于为数不多的主机数大于65536（216）的大型网络，A类网络地址的数量最多不超过 126（2^7-2）个，每个 A 类网络最多可以容纳 16777214（2^24-2）台主机
- B类：第一个八位组的最高两位恒定为10
  - 128.0.0.0 - 191.255.255.255
  - 默认掩码：255.255.0.0 或者 /16
  - 两个组 网络位 + 两个组 主机位
  - 此类地址用于主机数介于 256～65536（2^8～2^16）之间的中型网络，B类网络数量最多 16382（2^14-2）个
- C类：第一个八位组的最高三位恒定为110
  - 192.0.0.0 – 223.255.255.255
  - 默认掩码：255.255.255.0 或者 /24
  - 一个组 网络位 + 三个组 主机位
  - 用于每个网络只能容纳 254（2^8-2）台主机的大量小型网，C 类网络数量上限为 2097150（2^21-2）个
- D类：第一个八位组的最高四位恒定为1110
  - 224.0.0.0 – 239.255.255.255
  - 这个类别的地址专门用于组播





4. 网络掩码 Netmask

一个IP地址包含两部分：网络部分以及主机部分

- 网络部分用于表示这个IP地址所处的“空间”
- 如何区分一个IP地址中的网络与主机部分呢——网络掩码，用于和IP地址进行对应，从而标识出IP地址中的网络与主机部分

网络掩码：

- 32bits，与IPv4地址的位数是一样的
- 在二进制的表示上是一堆连续的1、后面接连续的0
- 值为1的bit对应IP地址中的网络位；为0的bit对应IP地址中的主机位，以此来辅助我们识别一个IP地址中的网络与主机位
- 往往使用**掩码长度**的方式来表示一个IP地址+掩码：192.168.1.1 255.255.255.0 等同于 192.168.1.1/24 （因为有24个1）

![2023-03-28-15-49-38](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-28-15-49-38.png)



5. IP 地址类型

- 网络地址：标识一个网络，相当于一个“面”的概念。是一个IP地址中主机位全0的地址。例如192.168.10.0/24。

- 广播地址：用于向网络中的所有主机发送数据的特殊地址。广播地址即主机部分的各比特位全部为1的地址。例如192.168.10.255/24。

- 主机地址：可分配给网络中终端设备的地址。例如192.168.10.1/24至192.168.10.254/24。
  - **去掉网络地址+广播地址**



特殊 IP 地址：
<img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-04-20-20-25-02.png" alt="2023-04-20-20-25-02" style="zoom: 60%;" />




#### 子网划分

- 子网划分的术语叫做VLSM（Variable Length Subnet Mask，可变长子网掩码）

eg. 假设我们有一个B类地址：172.16.0.0/16。默认情况下，这个B类地址的掩码为255.255.0.0，前两个八位组是网络位，后两个八位组是主机位。那么这个个单一的网络中，有2的16次方个IP地址

![2023-03-28-16-00-40](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-28-16-00-40.png)

现在，将原有的16个位的网络位向主机位去“借”一位，这样一来网络位就扩充到了17位，相对的主机位就变成了15位，借过来的这一位就是**子网位**了

- 掩码变成了 255.255.128.0 或者 /17
- 172.16.0.0/16 -> 172.16.0.0/17 和 172.16.128.0/17



#### 组播

1. 什么是组播？

- 组播指的是报文从一个源发出，**被转发到一组特定的接收者**，相同的报文在每条链路上最多有一份
- 相较于传统的单播和广播，组播可以有效地节约网络带宽、降低网络负载，所以**被广泛应用于IPTV、实时数据传送和多媒体会议等网络业务**中



2. 组播和单播的区别

- 组播和单播都是报文传输的一种方式
  - **单播**是主机间**一对一**的通讯模式，网络中的设备根据网络报文中包含的目的地址选择传输路径，将单播报文传送到指定的目的地，只对接收到的数据进行转发，不会进行复制。它能够针对每台主机及时的响应，现在的网页浏览全部都是采用单播模式。
  - **组播**是主机间**一对多**的通讯模式， 组播是一种允许一个或多个组播源发送同一报文到多个接收者的技术。组播源将一份报文发送到特定的组播地址，组播地址不同于单播地址，它并不属于特定某个主机，而是属于一组主机。一个组播地址表示一个群组，需要接收组播报文的接收者都加入这个群组。

- 组播传输和单播传输方式对比
  - 单播传输适用于用户稀少的网络，如果用户量较大时，网络将会出现多份相同的流量，会大量占用处理器资源而且非常浪费网络的带宽
  - 而通过组播方式传输，网络中每条链路中仅有一条数据流。组播相比于单播的优势在于相同的报文在每条链路上最多有一份。



3. 组播和广播的区别

- 组播和广播都是报文传输的一种方式
  - **广播**是主机间**一对所有**的通讯模式，设备会将报文发送到网络中的所有可能接收者。设备简单地将它收到的任何广播报文都复制并转发到除该报文到达的接口外的每个接口。广播处理流程简单，不用选择路径
  - **组播**是主机间**一对多**的通讯模式， 组播是一种允许一个或多个组播源发送同一报文到多个接收者的技术

- 组播传输和广播传输方式对比
  - 广播传输数据源必须与用户在同一个网段，组播可以跨网段传输。
  - 广播传输该网段内所有主机都能收到数据报文，会导致无信息需求的主机也收到该信息，网络中存在流量冗余，组播传输只将数据流传输到有接收者的地方，网络中不存在流量冗余。组播相比于广播的优势在于组播的报文是按需发送





4. 组播地址

- IPv4 组播地址

  IANA将D类地址空间分配给IPv4组播使用。IANA将**D类地址**空间分配给IPv4组播使用。IPv4地址一共32位，D类地址最高4位为1110，地址范围从224.0.0.0到239.255.255.255，具体分类及含义见下图：

  ![IPv4组播地址的范围及含义](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/download-1687749723825417.png)

- IPv6 组播地址

  IPv6地址长度是128位，IPv6组播地址格式如图所示：

  ![IPv6组播地址格式](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/download-1687749770871420.png)

  - IPv6组播地址总是以FF开头，高8位取值为11111111。
  - Flags字段（4位）用来标识组播地址的状态。例如取值为0表示保留组地址，取值为1或2表示ASM范围内的组播地址，取值为3表示SSM范围内的组播地址。
  - Scope字段（4位）用来标识组播组的应用范围，指示组播组应用范围是只包含同一本地网络、同一站点、同一机构中的节点，还是包含全球地址空间内的任何节点。
  - Group ID（112位）组播组标识符，用在由Scope字段所指定的范围内标识组播组。

  固定的IPv6组播地址的范围及含义如图所示：

  ![IPv6组播地址的范围及含义](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/download-1687749796604423.png)





5. 组播MAC地址的范围

- 以太网传输IPv4单播报文的时候，目的MAC地址使用的是接收者的MAC地址。但是在传输组播数据时，其目的地不再是一个具体的接收者，而是一个成员不确定的组，所以要使用IPv4组播MAC地址，即IPv4组播地址映射到链路层中的地址

- IPv4 组播MAC地址

  - IANA规定，IPv4组播MAC地址的高24位为0x01005e，第25位为0，低23位为IPv4组播地址的低23位，映射关系如图所示。例如组播组地址224.0.1.1对应的组播MAC地址为01-00-5e-00-01-01

    ![IPv4组播地址与IPv4组播MAC地址的映射关系](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/download-1687750079039426.png)

  - IPv4组播地址与IPv4组播MAC地址的映射关系

    - IPv4组播地址的前4位是固定的1110，对应组播MAC地址的高25位
    - IPv4组播地址的后28位中只有23位被映射到MAC地址，因此丢失了5位的地址信息，直接结果是有32个IPv4组播地址映射到同一MAC地址上。例如IP地址为224.0.1.1、224.128.1.1、225.0.1.1、239.128.1.1等组播组的组播MAC地址都为01-00-5e-00-01-01。

- IPv6 组播MAC地址

  - IPv6组播MAC地址的高16位为0x3333，低32位为IPv6组播地址的低32位。如图所示，是IPv6组播地址的MAC地址映射关系

    ![IPv6组播地址与IPv6组播MAC地址的映射关系](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/download-1687750282344429.png)

  - IPv6组播地址与IPv6组播MAC地址的映射关系

    - 可见IPv6中会有更多的组地址使用同一个MAC地址





6. 组播协议

- IPv4 网络中使用的组播协议

  - 组播组管理协议IGMP（Internet Group Management Protocol）

    IGMP是负责IPv4组播成员管理的协议，运行在组播网络中的最后一段，即三层网络设备与用户主机相连的网段内。IGMP协议在主机端实现组播组成员加入与离开，在上游的三层设备中实现组成员关系的维护与管理，同时支持与上层组播路由协议的信息交互。

  - 协议无关组播PIM（Protocol Independent Multicast）

    PIM作为一种IPv4网络中的组播路由协议，主要用于将网络中的组播数据流发送到有组播数据请求的组成员所连接的组播设备上，从而实现组播数据的路由查找与转发。

    PIM协议包括PIM-SM（Protocol Independent Multicast Sparse Mode）协议无关组播-稀疏模式和PIM-DM（Protocol Independent Multicast Dense Mode）协议无关组播－密集模式。PIM-SM适合规模较大、组成员相对比较分散的网络；PIM-DM适合规模较小、组播组成员相对比较集中的网络。

  - 组播源发现协议MSDP（Multicast Source Discovery Protocol）

    MSDP是为了解决多个PIM-SM域之间的互连的一种域间组播协议，用来发现其他PIM-SM域内的组播源信息，将远端域内的活动信源信息传递给本地域内的接收者，从而实现组播报文的跨域转发。

  - 组播边界网关协议MBGP（MultiProtocol Border Gateway Protocol）

    MBGP实现了跨AS域的组播转发。适用于组播源与组播接收者在不同AS域的场景。

  - IGMP Snooping

    IGMP Snooping功能可以使设备工作在二层时，通过侦听上游的三层设备和用户主机之间发送的IGMP报文来建立组播数据报文的二层转发表，管理和控制组播数据报文的转发，进而有效抑制组播数据在二层网络中扩散。

  - BIER

    BIER是基于比特索引的显式复制技术，通过将组播报文目的节点的集合以比特串的方式封装在报文头部进行发送，从而使网络中间节点无需为每一个组播流(Per-flow)建立组播树及保存组播流状态，仅需根据报文头部的目的节点的集合进行复制转发。

- IPv6 网络中使用的组播协议

  - 组播侦听者发现协议MLD（Multicast Listener Discovery）

    MLD是负责IPv6组播成员管理的协议，运行在组播网络中的最后一段，即三层组播设备与用户主机相连的网段内。MLD协议在主机端实现组播组成员加入与离开，在三层设备上实现组成员关系的维护与管理，同时支持与组播路由协议的信息交互。

  - PIM（IPv6）

    PIM（IPv6）作为一种IPv6网络中的组播路由协议，主要用于将网络中的组播数据流引入到有组播数据请求的组成员所连接的路由器上，从而实现组播数据流的路由查找与转发。

    PIM（IPv6）协议包括PIM-SM（IPv6）和PIM-DM（IPv6）两种模式。PIM-SM（IPv6）适合规模较大、组成员相对比较分散的网络；PIM-DM（IPv6）适合规模较小、组播组成员相对比较集中的网络。

  - MLD Snooping

    MLD Snooping功能可以使设备工作在二层时，通过侦听上游的三层设备和用户主机之间发送的MLD报文来建立组播数据报文的IPv6二层转发表，管理和控制组播数据报文的转发，进而有效抑制组播数据在二层网络中扩散

  - BIERv6

    BIERv6技术保留了BIER技术的优势，利用IPv6可扩展的能力，实现了组播路由技术在IPv6网络场景下的新应用。具有易部署、智能化、高可靠性三大特点。







### ARP 协议



#### 基础概念

- Address Resolution Protocol 地址解析协议：用来**将IP地址解析为MAC地址**的协议
- 一个主机要和另一个主机进行直接通信，必须要知道目标主机的MAC地址，目标MAC地址通过地址解析协议获得
- 主机或三层网络设备上会维护一张ARP表，用于存储IP地址和MAC地址的映射关系，一般ARP表项包括动态ARP表项和静态ARP表项





#### ARP 报文格式



ARP请求和应答的报文格式如下图所示：

![ARP请求和应答报文格式](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/download-1687750586220432.png)

- 报文的长度是42字节

- 前14字节的内容表示以太网首部，后28字节的内容表示ARP请求或应答报文的内容

- ARP报文各字段的含义

  ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/download-1687750622912435.png)





#### ARP 的类型

- 动态 ARP

  - 动态 ARP 表项由 ARP 协议**通过 ARP 报文自动生成和维护**，可以被老化，可以被新的 ARP 报文更新，也可以被静态 ARP 表项覆盖。
  - 动态 ARP 适用于拓扑结构复杂、通信实时性要求高的网络。

- 静态 ARP

  - 静态 ARP 表项是由网络管理员**手工建立**的 IP 地址和 MAC 地址之间固定的映射关系。静态 ARP 表项不会被老化，不会被动态 ARP 表项覆盖。

  - 静态 ARP 表项不会被老化，也不会被动态 ARP 表项覆盖，可以保证网络通信的安全性。静态 ARP 表项可以限制本端设备和指定 IP 地址的对端设备通信时只使用指定的 MAC 地址，此时攻击报文无法修改本端设备的 ARP 表中 IP 地址和 MAC 地址的映射关系，从而保护了本端设备和对端设备间的正常通信。**一般在网关设备上配置静态ARP表项。**

  - 静态ARP表项分为短静态ARP表项和长静态ARP表项。

    - **短静态ARP表项**：手工建立IP地址和MAC地址之间固定的映射关系，未同时指定VLAN和出接口。
      如果出接口是处于二层模式的以太网接口，短静态ARP表项不能直接用于报文转发。当需要发送报文时，设备会先发送ARP请求报文，如果收到的ARP应答报文中的源IP地址和源MAC地址与所配置的IP地址和MAC地址相同，则将收到ARP应答报文的VLAN和接口加入该静态ARP表项中，后续设备可直接用该静态ARP表项转发报文。

    - **长静态ARP表项**：手工建立IP地址和MAC地址之间固定的映射关系，并同时指定该ARP表项所在VLAN和出接口。

      长静态ARP表项可以直接用于报文转发。建议用户采用长静态ARP表项。

- 免费 ARP

  - 设备主动使用自己的IP地址作为目的IP地址发送ARP请求，此种方式称免费ARP。
  - 免费ARP有如下作用：
    - IP地址冲突检测：当设备接口的协议状态变为Up时，设备主动对外发送免费ARP报文。正常情况下不会收到ARP应答，如果收到，则表明本网络中存在与自身IP地址重复的地址。如果检测到IP地址冲突，设备会周期性的广播发送免费ARP应答报文，直到冲突解除。
    - 用于通告一个新的MAC地址：发送方更换了网卡，MAC地址变化了，为了能够在动态ARP表项老化前通告网络中其他设备，发送方可以发送一个免费ARP。
    - 在VRRP备份组中用来通告主备发生变换：发生主备变换后，MASTER设备会广播发送一个免费ARP报文来通告发生了主备变换。

- Proxy ARP

  - 如果ARP请求是从一个网络的主机发往同一网段但不在同一物理网络上的另一台主机，那么连接这两个网络的设备就可以回答该ARP请求，这个过程称作ARP代理(Proxy ARP)。
  - Proxy ARP有以下特点：
    - Proxy ARP部署在网关上，网络中的主机不必做任何改动。
    - Proxy ARP可以隐藏物理网络细节，使两个物理网络可以使用同一个网络号。
    - Proxy ARP只影响主机的ARP表，对网关的ARP表和路由表没有影响。
    - Proxy ARP分为路由式Proxy ARP、VLAN内Proxy ARP和VLAN间Proxy ARP。

- 路由式Proxy ARP

  - 路由式Proxy ARP就是使那些在同一网段却不在同一物理网络上的网络设备能够相互通信的一种功能。

  - 在实际应用中，如果连接设备的主机上没有配置缺省网关地址（即不知道如何到达本网络的中介系统），此时将无法进行数据转发。

  - 如下图所示，Host_1的IP地址为172.16.1.10/16，Host_2的IP地址为172.16.2.20/16，Host_1与Host_2处于同一网段。Switch通过VLAN10和VLAN20连接两个网络，VLANIF10和VLANIF20的IP地址不在同一个网段。

    ![路由式Proxy ARP典型组网应用](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/download-1687751290914438.png)

    当Host_1需要与Host_2通信时，由于目的IP地址与本机的IP地址为同一网段，因此Host_1以广播形式发送ARP请求报文，请求Host_2的MAC地址。但是，由于两台主机处于不同的物理网络（不同广播域）中，Host_2无法收到Host_1的ARP请求报文，因此也就无法应答。

    通过在Switch上启用路由式Proxy ARP功能，可以解决此问题。启用路由式Proxy ARP后，Switch收到ARP请求报文后，Switch会查找路由表。由于Host_2与Switch直连，因此Switch上存在到Host_2的路由表项。Switch使用自己的MAC地址给Host_1发送ARP应答报文。Host_1将以Switch的MAC地址进行数据转发。此时，Switch相当于Host_2的代理。如上图所示，Host_1上的ARP表项中到目的地址Host_2的IP地址对应的MAC地址为Switch的VLANIF10接口的MAC地址。

- VLAN内Proxy ARP

  - 如果两个用户属于相同的VLAN，但VLAN内配置了端口隔离。此时用户间需要三层互通，可以在关联了VLAN的接口上启动VLAN内Proxy ARP功能。

  - 如下图所示，Host_1和Host_2是Switch设备下的两个用户。连接Host_1和Host_2的两个接口在Switch属于同一个VLAN10。

    ![VLAN内Proxy ARP典型组网应用](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/download-1687751327782441.png)

    由于在Switch上配置了VLAN内不同接口彼此隔离，因此Host_1和Host_2不能直接在二层互通。

    若Switch的接口使能了VLAN内Proxy ARP功能，可以使Host_1和Host_2实现三层互通。Switch的接口在接收到目的地址不是自己的ARP请求报文后，Switch并不立即丢弃该报文，而是查找该接口的ARP表项。如果存在Host_2的ARP表项，则将自己的MAC地址发送给Host_1，并将Host_1发送给Host_2的报文代为转发。实际上此时Switch相当于Host_2的代理。

- VLAN间Proxy ARP

  - 如果两台主机处于相同网段但属于不同的VLAN，用户间要进行三层互通，可以在关联了这些VLAN的接口（例如VLANIF接口或者子接口）上使能VLAN间Proxy ARP功能。

  - 如下图所示，Host_1和Host_2是Switch设备下的两个用户，Host_1和Host_2处于相同网段，但Host_1属于VLAN10，Host_2属于VLAN20。

    ![VLAN间Proxy ARP典型组网应用](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/download-1687751394543444.png)

    由于Host_1和Host_2属于不同的Sub-VLAN，Host_1和Host_2不能直接实现二层互通。

    如果Switch上使能了VLAN间Proxy ARP功能，可以使Host_1和Host_2实现三层互通。Switch的接口在接收到目的地址不是自己的ARP请求报文后，并不立即丢弃该报文，而是查找ARP表项（包括动态学习的ARP表项和静态配置的ARP表项）。如果存在Host_2的ARP表项，则将自己的MAC地址发送给Host_1，并将Host_1发送给Host_2的报文代为转发。实际上此时Switch相当于Host_2的代理。



#### ARP如何进行地址解析

动态 ARP 的 两个过程：

- 广播 ARP 请求
- 单播 ARP 应答



![ARP地址解析过程](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/download-1687760811677447.png)



当需要通信的两台主机处于同一网段时，如上图中的Host_1和Host_3，Host_1要向Host_3发送数据。

- 首先，Host_1会查找自己本地缓存的ARP表，确定是否包含Host_3对应的ARP表项。如果Host_1在ARP表中找到了Host_3对应的MAC地址，则Host_1直接利用ARP表中的MAC地址，对数据报文进行帧封装，并将数据报文发送给Host_3。如果Host_1在ARP表中找不到Host_3对应的MAC地址，则先缓存该数据报文，并以广播方式发送一个ARP请求报文。如上图中所示，OP字段为1表示该报文为ARP请求报文，ARP请求报文中的源MAC地址和源IP地址为Host_1的MAC地址和IP地址，目的MAC地址为全0的MAC地址，目的IP地址为Host_3的IP地址。
- Switch_1收到ARP请求报文后，将该ARP请求报文在同一广播域内转发。
- 同一广播域内的主机Host_2和Host_3都能接收到该ARP请求报文，但只有被请求的主机（即Host_3）会对该ARP请求报文进行处理。Host_3比较自己的IP地址和ARP请求报文中的目的IP地址，当两者相同时进行如下处理：将ARP请求报文中的源IP地址和源MAC地址（即Host_1的IP地址和MAC地址）存入自己的ARP表中。之后以单播方式发送ARP应答报文给Host_1，ARP应答报文内容如上图中所示，OP字段为2表示该报文为ARP应答报文，源MAC地址和源IP地址为Host_3的MAC地址和IP地址，目的MAC地址和目的IP地址为Host_1的MAC地址和IP地址。
- Switch_1收到ARP应答报文后，将该ARP应答报文转发给Host_1。Host_1收到ARP应答报文后，将Host_3的MAC地址加入到自己的ARP表中以用于后续报文的转发，同时将数据报文进行帧封装，并将数据报文发送给Host_3。

当需要通信的两台主机处于不同网段时，如上图中的Host_1和Host_4，Host_1上已经配置缺省网关，Host_1首先会发送ARP请求报文，请求网关Router的IP地址对应的MAC地址。Host_1收到ARP应答报文后，将数据报文封装并发给网关，再由网关将数据报文发送给目的主机Host_4。Host_1学习网关IP地址对应的ARP表项的过程，以及网关设备学习Host_4的IP地址对应的ARP表项的过程与上述同网段主机Host_1和Host_3之间进行ARP地址解析的过程类似，不再赘述。



还有一个讲的挺清楚的

https://blog.csdn.net/asdfsadfasdfsa/article/details/87556777





#### ARP 老化机制



- 如果每次Host_1和Host_3通信前都要发送一个广播的ARP请求报文，会极大的增加网络负担。而且同广播域的所有设备都需要接收和处理这个广播的ARP请求报文，也极大的影响了网络中设备的运行效率

- 为了解决以上问题，每台主机或设备上都维护着一个高速缓存，这是ARP高效运行的一个关键。在这个高速缓存中，存放主机或设备最近学习到的IP地址到MAC地址的映射关系，即**动态ARP表项**。

- 主机或设备每次发送报文时，会先在本地高速缓存中查找目的IP地址所对应的MAC地址。如果高速缓存中有对应的MAC地址，主机或设备不会再发送ARP请求报文，而是直接将报文发至这个MAC地址；如果高速缓存中没有对应的MAC地址，主机或设备才会广播发送ARP请求报文，进行ARP地址解析。

- 一方面由于高速缓存的容量限制，另一方面为了保证高速缓存中ARP表项的准确性，设备会对动态ARP表项进行老化和更新。

  - 动态ARP表项的老化参数有：老化超时时间、老化探测次数和老化探测模式。

  - 设备上动态ARP表项到达老化超时时间后，设备会发送老化探测报文（即ARP请求报文），如果能收到ARP应答报文，则更新该动态ARP表项，本次老化探测结束；

    如果超过设置的老化探测次数后仍没有收到ARP应答报文，则删除该动态ARP表项，本次老化探测结束。

  - 设备发送的老化探测报文可以是单播报文，也可以是广播报文。缺省情况下，设备只在最后一次发送ARP老化探测报文是广播模式，其余均为单播模式发送。当对端设备MAC地址不变时，可以配置接口以单播模式发送ARP老化探测报文。

  - 当接口Down时设备会立即删除相应的动态ARP表项。







### ICMP 协议



#### 基础概念

- 因特网控制报文协议ICMP（Internet Control Message Protocol）
- 是一个差错报告机制，是TCP/IP协议簇中的一个重要子协议，通常被IP层或更高层协议（TCP或UDP）使用，属于**网络层协议**
- 主要用于**在IP主机和路由器之间传递控制消息**，用于报告主机是否可达、路由是否可用等
  - 控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息

- 总结：
  - ICMP的功能是**检错**而不是纠错
  - 它**将出错的报文返回给发送方的设备**，发送方根据ICMP报文确定「错误类型」，从而更好的重发错误的数据包
  - 我们用来测试网络连通性的 ping 命令，就是ICMP的工作过程





#### 报文格式

<img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/04f608a73fe240d98dae318fc583e70d.png" alt="img" style="zoom:67%;" />

ICMP是IP协议的一部分，ICMP协议的报文包含在IP数据报的数据部分

- 类型（Type）：8位，标明ICMP报文的作用及格式
- 代码（Code）：8位，标明报文的类型
- 校验和：16位，检验报文是否有误



完整的：

![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/b9c1755d343b4db08ee77efd6761d8cb.png)



几种常见的ICMP报文类型

![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/b4b4feb411e74534a01a359f581951bc.png)



1）回显应答和请求

- ICMP 回送请求报文是由主机或路由器向一个特定的目的主机发出的询问。收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。这种询问报文用来测试目的站是否可达以及了解其有关状态。
- **Ping命令**，使用的就是响应请求（Type=8）和应答（Type=0），一台主机向一个节点发送一个 Type=8 的 ICMP 报文，如果途中没有异常，则目标返回 Type=0 的 ICMP 报文，说明这台主机存在

2）目标不可达

- 当路由器或主机不能交付数据报时就向源点发送目标不可达报文。例如我们要连接对方一个不存在的系统端口时，将返回 Type=3，Code=3 的 ICMP 端口不可达报文。
- 常见的不可到达类型还有网络不可到达（Code=0）、主机不可到达（Code=1）、协议不可到达（Code=2）等

3）时间超过

- 无连接方式网络的问题就是数据报会丢失，或者长时间在网络游荡而找不到目标，或者拥塞导致主机在规定时间内无法重组数据报分段，这时就要触发 ICMP 超时报文的产生。
- 超时报文（Type=11）的代码域有两种取值：传输超时（Code=0），表示重组分段超时（Code=1）

4）时间戳

- 时间戳请求与回答可用于时钟同步和时间测量。时间戳请求报文（Type=13）和时间戳应答报文（Type=14）可以用于测试两台主机之间数据报来回一次的传输时间。
- 传输时，主机填充原始时间戳，接收方收到请求后填充接收时间戳后以Type=14的报文格式返回，发送方计算这个时间差





















### MPLS


https://info.support.huawei.com/info-finder/encyclopedia/zh/MPLS.html



1. MPLS

- MPLS —— Multi-Protocol Label Switching 多协议标签交换
  - Multi-Protocol：支持多种三层协议，如IP、IPv6、IPX、等
  - Label Switching：给报文打上标签，**以标签交换取代IP转发**
- 2.5层协议：位于网络层和链路层之间
- 作用：
  - 一种新的网络交换方式：将IP地址映射为简短且长度固定、只具有本地意义的标签，以标签交换替代IP查表，从而显著提升转发效率
  - 同时，MPLS的标签机制可以在IP网络中构筑一条逻辑上的隧道，而且MPLS兼容不同的网络层和链路层协议，因此MPLS可以很好的为各种L2VPN、L3VPN以及EVPN业务提供公网隧道服务



1. MPLS 组网

![2023-04-20-20-41-10](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-04-20-20-41-10.png)

- LER
- LSR

https://cshihong.blog.csdn.net/article/details/80503389?spm=1001.2101.3001.6650.13&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-13-80503389-blog-125325031.235%5Ev30%5Epc_relevant_default_base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-13-80503389-blog-125325031.235%5Ev30%5Epc_relevant_default_base&utm_relevant_index=20








## VLAN 虚拟局域网


https://blog.csdn.net/pcyear/article/details/108466987?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-108466987-blog-124531883.235%5Ev30%5Epc_relevant_default_base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-108466987-blog-124531883.235%5Ev30%5Epc_relevant_default_base&utm_relevant_index=2



### VLAN 概述

- VLAN（Virtual Local Area Network）即虚拟局域网，是将一个物理的 LAN 在逻辑上划分成多个广播域（多个VLAN）的通信技术
- VLAN 内的主机间可以直接通信，而VLAN间不能直接互通，从而将广播报文限制在一个VLAN 内。
- VLAN 聚合（VLAN aggregation）用于解决多个 VLAN 占用多个 IP 地址的问题。 VLAN 聚合将多个 VLAN 集中在一起，形成一个 super-VLAN。组成 super-VLAN 的 VLAN 被称作sub-VLAN，所有 sub-VLAN 共用一个IP 网段。
- QinQ（802.1Q-in-802.1Q）技术是一项扩展 VLAN 空间的技术，通过在 802.1Q 标签报文的基础上再增加一层 802.1Q 的标签头来达到扩展 VLAN 空间的功能。



### VLAN 的产生

- 从任意节点发出的消息都会被发送到其他节点，形成广播
- 所有主机共享一条传输通道，无法控制网络中的信息安全
- 为减少广播，需要在没有互访需求的主机之间进行隔离
- 路由器是基于三层 IP 地址信息来选择路由，其连接两个网段时可以有效抑制广播报文的转发，但成本高

所以有了 VLAN

- VLAN 将一个物理的LAN 在逻辑上划分成多个广播域（多个VLAN）
- VLAN 内的主机间可以直接通信，而VLAN 间不能直接互通
- 广播报文被限制在一个VLAN内，同时提高了网络安全性


![2023-04-20-21-05-51](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-04-20-21-05-51.png)



### SUPER-VLAN

- VLAN间二层不能直接互通，需要通过三层才能通信
- 三层划分子网时，需要给各个子网分配子网号、子网定向广播地址、子网缺省网关地址，当子网划分过多时，会浪费很多地址，导致ip地址紧缺。
- 实现VLAN aggregation 后，只在super-VLAN 接口上配置IP 地址，而不必为每个sub-VLAN 分配IP 地址。所有sub-VLAN 共用IP 网段，解决了IP 地址资源浪费的问题



### QinQ







## VXLAN



### VXLAN 概述

- **VXLAN** 全称是 Virtual eXtensible Local Area Network，虚拟扩展局域网
- 是由IETF定义的NVO3（Network Virtualization over Layer 3）标准技术之一，是对传统VLAN协议的一种扩展
- 它是一种 overlay 技术，**通过三层的网络来搭建虚拟的二层网络**
- **本质上是一种隧道技术**，在源网络设备与目的网络设备之间的 IP 网络上，建立一条逻辑隧道，将用户侧报文经过特定的封装后通过这条隧道转发





### 为什么需要 VXLAN



- 服务器虚拟化后出现了虚拟机动态迁移，要求提供一个无障碍接入的网络

  ```markdown
  1. 什么是服务器虚拟化技术？
  - 传统的数据中心物理服务器利用率太低，平均只有10%～15%，浪费了大量的电力能源和机房资源，所以出现了服务器虚拟化技术
  - 服务器虚拟化技术是把一台物理服务器虚拟化成多台逻辑服务器，这种逻辑服务器被称为虚拟机（VM）。每个VM都可以独立运行，有自己的操作系统、APP，当然也有自己独立的MAC地址和IP地址，它们通过服务器内部的虚拟交换机（vSwitch）与外部实体网络连接。
  - 通过服务器虚拟化，可以有效地提高服务器的利用率，降低能源消耗，降低数据中心的运营成本，所以虚拟化技术目前得到了广泛的应用
  
  2. 什么是虚拟机动态迁移？
  - 虚拟机动态迁移，就是在保证虚拟机上服务正常运行的同时，将一个虚拟机系统从一个物理服务器移动到另一个物理服务器的过程。该过程对于最终用户来说是无感知的，从而使得管理员能够在不影响用户正常使用的情况下，灵活调配服务器资源，或者对物理服务器进行维修和升级。
  - 在服务器虚拟化后，虚拟机动态迁移变得常态化，为了保证迁移时业务不中断，就要求在虚拟机迁移时，不仅虚拟机的IP地址不变，而且虚拟机的运行状态也必须保持原状（例如TCP会话状态），所以虚拟机的动态迁移只能在同一个二层域中进行，而不能跨二层域迁移。
  - 为了打破这种限制，实现虚拟机的大范围甚至跨地域的动态迁移，就要求把VM迁移可能涉及的所有服务器都纳入同一个二层网络域，这样才能实现VM的大范围无障碍迁移。
  
  3. VXLAN如何满足虚拟机动态迁移时对网络的要求？
  - 同一台二层交换机可以实现下挂服务器之间的二层通信，而且服务器从该二层交换机的一个端口迁移到另一个端口时，IP地址是可以保持不变的。这样就可以满足虚拟机动态迁移的需求了。VXLAN的设计理念和目标正是由此而来的。
  - VXLAN可以提供一套方法论，在数据中心IP网络基础上，构建一张全互联的二层隧道虚拟网络，保证任意两点之间都能通过VXLAN隧道来通信，并忽略底层网络的结构和细节。从服务器的角度看，VXLAN为它们将整个数据中心基础网络虚拟成了一台巨大的“二层交换机”，所有服务器都连接在这台虚拟二层交换机上。而基础网络之内如何转发都是这台“巨大交换机”内部的事情，服务器完全无需关心
  ```

- 数据中心规模越发庞大，租户数量激增，需要网络提供隔离海量租户的能力

  ```markdown
  - 在传统的VLAN网络中，标准定义所支持的可用VLAN数量只有4000个左右。服务器虚拟化后，一台物理服务器中承载了多台虚拟机，每个虚拟机都有独立的IP地址和MAC地址，相当于接入数据中心的服务器成倍扩大了。另外，公有云或其它大型虚拟化云数据中心动辄需容纳上万甚至更多租户，VLAN的能力显然已经力不从心。
  - VXLAN如何来解决上述问题呢？VXLAN在VXLAN帧头中引入了类似VLAN ID的网络标识，称为VXLAN网络标识VNI（VXLAN Network ID），由24比特组成，理论上可支持多达16M的VXLAN段，从而满足了大规模不同网络之间的标识、隔离需求
  ```

  

采用 VXLAN 可以满足上述两个关键需求。







### VXLAN 基本概念

![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/download.png)



- **VTEP**（VXLAN Tunnel End Point，VXLAN隧道端点）

  - VXLAN 网络的**边缘设备**

  - VXLAN 的相关处理都在 VTEP 上进行，例如识别以太网数据帧所属的 VXLAN、基于 VXLAN 对数据帧进行二层转发、**封装/解封装报文**等
    - 源服务器发出的原始数据帧，在 VTEP 上被封装成 VXLAN 格式的报文，并在 IP 网络中传递到另外一个 VTEP 上，并经过解封转还原出原始的数据帧，最后转发给目的服务器

  - VTEP可以是一台独立的**物理设备**，也可以是虚拟机所在服务器的**虚拟交换机**

- **VNI**（VXLAN Network Identifier，VXLAN网络标识符）
  - VNI 是一种类似于 VLAN ID 的用户标识，一个 VNI 代表了一个租户，属于不同 VNI 的虚拟机之间不能直接进行二层通信
  - VXLAN 报文封装时，给 VNI 分配了24比特的长度空间
  - 在分布式网关部署场景下，VNI 还可分为二层 VNI 和三层 VNI，它们的作用不同：

    - 二层 VNI 是普通的 VNI，以1：1方式映射到广播域 BD，实现 VXLAN 报文同子网的转发
    - 三层 VNI 和 VPN 实例进行关联，用于 VXLAN 报文跨子网的转发
- **VXLAN Tunnel**
  - 两个VTEP之间点到点的**逻辑隧道**
  - VTEP为数据帧封装VXLAN头、UDP头、IP头后，通过VXLAN隧道将封装后的报文转发给远端VTEP，远端VTEP对其进行解封装。
- **VSI**（Virtual Switching Instance，虚拟交换实例）
  - VSI 是 VTEP 上为一个 VXLAN 提供二层交换服务的**虚拟交换实例**
  - VSI可以看作是**VTEP上的一台基于VXLAN进行二层转发的虚拟交换机**，它具有传统以太网交换机的所有功能，包括源MAC地址学习、MAC地址老化、泛洪等
  - VSI 与 VXLAN 一一对应
- **VSI-Interface**（VSI的虚拟三层接口）
  - 类似于 Vlan-Interface，用来处理跨 VNI 即跨 VXLAN 的流量
  - VSI-Interface 与 VSI 一一对应，在没有跨 VNI 流量时可以没有 VSI-Interface

![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/1d71247d9cd1eec4d0b675b62c9b4c1f.jpeg)

现有 VTEP 设备中，一般用“接口+VLAN”的方式来区分流量与 VSI 的对应关系，而 VSI 与 VXLAN Tunnel 之间既可以建立全连接，也可以根据需求进行关联





哪些 VTEP 之间需要建立 VXLAN 隧道？

数据中心网络存在多个 VTEP，例如图中VTEP_1连接的VM、VTEP_2连接的VM以及VTEP_3连接的VM之间需要“大二层”互通，那VTEP_1、VTEP_2和VTEP_3之间就需要两两建立VXLAN隧道

![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/download-1687678006555404.png)

![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/download-1687678017321407.png)

- 什么是”同一大二层域“

  - 同一大二层域：类似于传统网络中VLAN（虚拟局域网）的概念，只不过在VXLAN网络中，它有另外一个名字，叫做Bridge-Domain，简称BD

  - 不同的VLAN是通过VLAN ID来进行区分的，那不同的BD是如何进行区分的呢？

    - 通过VNI来区分的

  - 对于CloudEngine系列交换机而言，BD与VNI是1：1的映射关系，这种映射关系是通过在VTEP设备上配置命令行建立起来的，配置样例如下：

    ```
    bridge-domain 10   //表示创建一个“大二层广播域”BD，其编号为10
     vxlan vni 5000  //表示在BD 10下，指定与之关联的VNI为5000
    #
    ```

- 如何确定报文属于哪个BD

  - 并非所有进入到交换机的报文都会走VXLAN隧道（也可能报文就是走普通的二三层转发流程）

  - 哪些报文要进入VXLAN隧道？

    - 传统网络中定义了三种不同类型的接口：Access、Trunk、Hybrid。这三种类型的接口虽然应用场景不同，但它们的最终目的是一样的：一是根据配置来检查哪些报文是允许通过的；二是判断对检查通过的报文做怎样的处理。

    - 在VXLAN网络中，VTEP上的接口也承担着类似的任务，只不过在CloudEngine系列交换机中，这里的接口不是物理接口，而是一个叫做“二层子接口”的逻辑接口。类似的，二层子接口主要做两件事：一是根据配置来检查哪些报文需要进入VXLAN隧道；二是判断对检查通过的报文做怎样的处理。在二层子接口上，可以根据需要定义不同的流封装类型（类似于传统网络中不同的接口类型）

      CloudEngine系列交换机目前支持的流封装类型有dot1q、untag、qinq和default四种类型：

      - dot1q：对于带有一层VLAN Tag的报文，该类型接口只接收与指定VLAN Tag匹配的报文；对于带有两层VLAN Tag的报文，该类型接口只接收外层VLAN Tag与指定VLAN Tag匹配的报文。
      - untag：该类型接口只接收不带VLAN Tag的报文。
      - qinq：该类型接口只接收带有指定两层VLAN Tag的报文。
      - default：允许接口接收所有报文，不区分报文中是否带VLAN Tag。不论是对原始报文进行VXLAN封装，还是解封装VXLAN报文，该类型接口都不会对原始报文进行任何VLAN Tag处理，包括添加、替换或剥离。

      除二层子接口外，还可以将VLAN作为业务接入点。将VLAN绑定到广播域BD后，加入该VLAN的接口即为VXLAN业务接入点，进入接口的报文由VXLAN隧道处理。

  - 将二层子接口加入BD

    - 要将二层子接口加入指定的BD，然后根据二层子接口上的配置，设备就可以确定报文属于哪个BD啦

    - 一台虚拟化服务器中有两个不同VLAN的虚拟机VM1（VLAN 10）和VM2（VLAN 20），它们与其他虚拟机通信时需要接入VXLAN网络。此时我们可以分别在VTEP的物理接口10GE 1/0/1上，分别针对VM1和VM2封装不同的二层子接口，并将其分别加入不同的BD。这样后续VM1和VM2的流量将会进入不同的VXLAN隧道继续转发

      在这个举例中，vSwitch的上行口配置成Trunk模式，且PVID为20。这样vSwitch发给VTEP的报文中，既有带tag的VM1流量，又有untag的VM2流量，此时在VTEP的接入口上创建两个二层子接口，分别配置为dot1q和untag的封装类型。

      ![img](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/download-1687695741439410.png)

      在CloudEngine交换机的接入物理接口10GE 1/0/1上，分别创建二层子接口10GE 1/0/1.1和10GE 1/0/1.2，并分别配置其流封装类型为dot1q和untag。

      ```
      interface 10GE1/0/1.1 mode l2   //创建二层子接口10GE1/0/1.1
       encapsulation dot1q vid 10   //只允许携带VLAN Tag 10的报文进入VXLAN隧道
       bridge-domain 10   //指定报文进入的是BD 10
      #
      interface 10GE1/0/1.2 mode l2   //创建二层子接口10GE1/0/1.2
       encapsulation untag   //只允许不携带VLAN Tag的报文进入VXLAN隧道
       bridge-domain 20   //指定报文进入的是BD 20
      #
      ```





### VXLAN 网关

和VLAN类似，不同VNI之间的主机，以及VXLAN网络和非VXLAN网络中的主机不能直接相互通信。

VXLAN网关分为二层网关和三层网关：

- VXLAN二层网关：用于终端接入VXLAN网络，也可用于同一VXLAN网络的子网通信。
- VXLAN三层网关：用于VXLAN网络中跨子网通信以及访问外部网络。











### VXLAN隧道是怎么建立的



1. 手工方式

- 这种方式需要用户手动指定VXLAN隧道的源IP为本端VTEP的IP、目的IP为对端VTEP的IP，也就是人为地在本端VTEP和对端VTEP之间建立静态VXLAN隧道

- 对于CloudEngine系列交换机，以上配置是在NVE（Network Virtualization Edge）接口下完成的，配置举例如下：

  ```
  interface Nve1   //创建逻辑接口NVE 1
   source 1.1.1.1   //配置源VTEP的IP地址（推荐使用Loopback接口的IP地址）
   vni 5000 head-end peer-list 2.2.2.2   
   vni 5000 head-end peer-list 2.2.2.3   
  #
  ```

  其中，**vni 5000 head-end peer-list 2.2.2.2**和**vni 5000 head-end peer-list 2.2.2.3**的配置，表示属于VNI 5000的对端VTEP有两个，IP地址分别为2.2.2.2和2.2.2.3。根据这两条配置，VTEP上会生成如下所示的一张表：

  ```
  <HUAWEI> display vxlan vni 5000 verbose
      BD ID                 : 10 
      State                  : up 
      NVE                    : 288
      Source Address      : 1.1.1.1
      Source IPv6 Address    : -
      UDP Port               : 4789 
      BUM Mode               : head-end
      Group Address          : -  
      Peer List            : 2.2.2.2 2.2.2.3  
      IPv6 Peer List         : -
  ```

  根据上表中的**Peer List**，本端VTEP就可以知道属于同一BD（或同一VNI）的对端VTEP都有哪些，这也就决定了同一大二层广播域的范围。当VTEP收到BUM（Broadcast&Unknown-unicast&Multicast，广播&未知单播&组播）报文时，会将报文复制并发送给Peer List中所列的所有对端VTEP（这就好比广播报文在VLAN内广播）。

  因此，这张表也被称为“头端复制列表”。

  当VTEP收到已知单播报文时，会根据VTEP上的MAC表来确定报文要从哪条VXLAN隧道走。而此时Peer List中所列的对端，则充当了MAC表中“出接口”的角色。





2. 自动方式

- 自动方式下VXLAN隧道的建立需要借助于EVPN（Ethernet VPN）协议
- 如何确定报文要进哪条隧道?
  - 属于同一BD的VXLAN隧道可能不止一条，比如上文的头端复制列表中，同一个源端VTEP（1.1.1.1）对应了两个对端VTEP（2.2.2.2和2.2.2.3）
  - 



### VXLAN 网络通信过程

1. 大致的通信过程

- 虚拟机的报文通过 VTEP 添加上 vxlan 以及外部的报文层，然后发送出去
- 对方 VTEP 收到之后拆除 vxlan 头部然后根据 VNI 把原始报文发送到目的虚拟机



2. VXLAN 报文

![image-20230625115102921](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20230625115102921.png)

- 内层报文：通信的虚拟机双方要么直接使用 IP 地址，要么通过 DNS 等方式已经获取了对方的 IP 地址，因此网络层地址已经知道。同一个网络的虚拟机需要通信，还需要知道对方虚拟机的 MAC 地址，vxlan 需要一个机制来实现传统网络 ARP 的功能
- VXLAN 头部（VXLAN header）：只需要知道 VNI，这一般是直接配置在 VTEP 上的，要么是提前规划写死的，要么是根据内部报文自动生成的，也不需要担心
  - Flags：8比特，取值为00001000
  - VNI：VXLAN网络标识，24比特，用于区分VXLAN段
  - Reserved：24比特和8比特，必须设置为0
- 外层 UDP 头部：最重要的是源地址和目的地址的端口
  - 源端口号是内层以太报文头通过哈希算法计算后的值
  - 目的端口也是写死的，比如 IANA 规定的 4789 端口
- 外层 IP 头部：IP 头部关心的是 VTEP 双方的 IP 地址
  - 源 IP 地址为发送报文的虚拟机所属 VTEP 的 IP 地址
  - 目的 IP 地址是目的虚拟机所属 VTEP 的 IP 地址
- 外层 Ethernet 头部：如果 VTEP 的 IP 地址确定了，MAC 地址可以通过经典的 ARP 方式来获取，毕竟 VTEP 网络在同一个三层，经典网络架构那一套就能直接用了
  - MAC SA：发送报文的虚拟机所属 VTEP 的 MAC 地址
  - MAC DA：目的虚拟机所属 VTEP 上路由表中直连的下一跳 MAC 地址
  - VLAN Type：可选字段，当报文中携带 VLAN Tag 时，该字段取值为0x8100
  - Ethernet Type：以太报文类型，IP 协议报文该字段取值为 0x0800



3. 具体实现

有两种实现：

- 多播：同个 vxlan 网络的 vtep 加入到同一个多播网络，如果需要知道以上信息，就在组内发送多播来查询
- 控制中心：在某个集中式的地方保存了所有虚拟机的上述信息，自动化告知 vtep 它需要的信息



1）多播

- 简单介绍多播：每个多播组对应一个多播 IP 地址，往这个多播 IP 地址发送的报文会发给多播组的所有主机

- 为什么要使用多播？

  因为 vxlan 的底层网络是三层的，广播地址无法穿越三层网络，要给 vxlan 网络所有 vtep 发送报文只能通过多播

- 






## EVPN



## IP 路由



1. IP 路由

- 当路由器（或者其他三层设备）收到一个IP数据包，路由器会找出报文中的IP头里的目的IP地址，然后拿着目的IP地址到自己的路由表（Routing Table）中进行查找，找到“最匹配”的路由条目后，将数据包根据路由条目所指示的出接口或下一跳IP转发出去，这就是路由（Routing）
- 每台路由器都会在本地维护一个路由表，路由表中装载着路由器通过各种途径获知的路由条目（Routes），每一条路由条目由路由前缀（路由所关联的目的网络号）、路由信息来源、出接口或下一跳IP、优先级、开销等信息元素构成


2. IP 路由表

![2023-03-28-16-14-54](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-28-16-14-54.png)

每个路由条目至少包括下面几个信息元素：

- 路由前缀：这是路由条目所关联的目的网络号。一条完整的路由前缀由：网络号+前缀长度构成，两者缺一不可，例如192.168.1.0/24与192.168.1.0/25，虽然网络号相同，都是192.168.1.0，但是两者绝对是两条不同的路由、两个不同的路由前缀，因为他们的前缀长度不相同。

- 协议类型：本条路由是通过什么途径学习到的，例如是直连的，或是静态的，或者是通过OSPF、IS-IS、EIGRP、BGP等动态路由学习到的。

- 优先级：与协议类型对应，路由表中路由的获取来源有多种，每种协议类型对应不同的优先级，优先级值越小越优先。

- 开销Cost：或者叫度量值。指的是本地到达该路由所关联的目的网络所需的开销。直连及静态路由的cost为0。通过动态路由协议学习到的Cost则根据实际环境。

- 指向目标的指针：指针不是指向路由器的直连目标网络就是指向直连网络内的另一台路由器地址，或者是到这个链路的本地接口。更接近目标网络一跳的路由器叫下一跳（next hop）路由器。


3. 路由优先级 Preference

- 当路由器从两种不用的途径获知去往同一个目的地的两条下一跳不相同的路由，那么路由器会比较这两条路由的优先级（Preference），优选Pre值小的路由
- 如果Pre值相等，例如是同种路由协议获取到的，则进一步比较开销（Cost）值

![2023-03-28-16-39-38](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-28-16-39-38.png)

R3与R1运行的是RIP协议，R3又通过OSPF与R2建立邻接关系。于是R3同时从RIP及OSPF学习到了去往目的地1.1.1.0/24的路由，这两条路由分别以R1和R2作为下一跳。那么R3最终选择OSPF的路由装载进路由表，也就是将R2作为实际去往1.1.1.0/24的下一跳，因为OSPF协议的优先级值比RIP要小、要更优

针对不同的路由协议，对应的优先级：不同的厂家，可能有所不同，下表中罗列的是我司的产品特性


![2023-03-28-16-40-08](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-28-16-40-08.png)






4. 静态路由

1）

路由器是为了：维护路由表以及依据路由表进行数据转发
路由表中包含通过各种途径学习到的路由表项或路由条目，主要有如下几种途径：

- 直连路由自动学习
- 使用静态路由的方式手工添加路由条目
- 使用动态路由协议使得设备之间能够进行路由信息的更新及学习，动态的维护路由表项

![2023-03-28-16-47-35](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-28-16-47-35.png)

当PC1要访问PC2时，由于PC1的网关设置为R1的GE0/0/0口的IP地址，于是PC1将目的地址为172.16.2.1的IP数据包发送给它的网关。而当R1收到这个数据包时，R1发现这个数据包的目的地址是172.16.2.1，那么它就去查找自己的路由表，结果发现路由表中，并没有匹配172.16.2.1的条目，因此数据包被丢弃

但是我们可以使用静态手工的方式哦来添加去往172.16.2.0/24网络的路由条目，这种方式添加的路由称为静态路由
```ip route-static 172.16.2.0 24 172.16.100.2```

![2023-03-28-16-48-35](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-28-16-48-35.png)

当R1收到PC1发往172.16.2.1的数据包，它仍然查看路由表，发现路由表中有一个条目匹配，于是R1将该数据包丢给该条路由指示的下一跳IP 172.16.100.2，这个数据包被传输到了R2


2） 

静态路由的配置：

方法一：关联下一跳IP的方式：

```ip route-static 172.16.2.0 24 172.16.100.2```

- 红色字体部分为该路由条目的网络号
- 蓝色字体部分为该网络号的掩码或者前缀长度
- 绿色字体部分为去往该网络的下一跳IP

方法二：关联出接口的方式：

```ip route-static 172.16.2.0 24 gigabitethernet0/0/1```

- 红色字体部分为该路由条目的网络号
- 蓝色字体部分为该网络号的掩码或者前缀长度
- 绿色字体部分为去往该网络的出接口


3）默认路由

由于R1仅有一条出口线路，因此我们可以在R1上配置一条默认路由， 下一跳为R2，如此即可在保证R1到R2后方三个网络可达的同时，路由条目达到最简：

```ip route-static 0.0.0.0 0 172.16.100.2```

默认路由可匹配任意目的网络前缀



4）浮动静态路由

![2023-03-28-16-54-11](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-28-16-54-11.png)

如果两条静态路由都是去往同一个目的地，分别采用不同的下一跳IP，同时这两条路由具备相同的优先级，以及相同的开销（cost，都为0）
-> 路由的等价负载均衡

存在隐患：有可能到达目的地的数据包是非顺序的

如果我希望R2去往10.9.9.0/24的流量始终先走单边（如R1），当R1宕机或R1-R2之间的互联链路出现故障时，R2能够自动将流量切换到R3呢？

使用 浮动静态路由
```ip route-static 10.9.9.0 24 10.1.12.1 #静态路由默认优先级为60```
```ip route-static 10.9.9.0 24 10.1.23.3 preference 80  #这条路由的优先级被设置为80```

这两条路由，就会进行优先级的比较，优先级小的路由将最终被放进路由表并作为数据转发的依据，另一条优先级为80的路由，则“潜藏”起来，并不出现在路由表中
当R1宕机，或者R1-R2之间的直连链路发生故障时，ip route-static 10.9.9.0 24 10.1.12.1这条静态路由失效，ip route-static 10.9.9.0 24 10.1.23.3 preference 80也就浮现出来了，因此这是一种不错的路径备份机制



5. 路由汇总

- 通过操作 子网掩码 来完成

eg. 172.16.1.0/24至172.16.31.0/24

![2023-03-28-17-07-03](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-28-17-07-03.png)

可以这么配置：

![2023-03-28-17-07-27](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-28-17-07-27.png)



6. 最长匹配原则

当路由器收到一个IP数据包时，会将数据包IP头部中的目的IP地址与自己本地路由表中的表项进行bit by bit（逐位）查找，直到找到匹配度最长的条并按照这个条目所指示进行，这叫最长匹配原则

![2023-03-28-17-17-35](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-28-17-17-35.png)

灰色的：172.16.0.0/16：B类地址 主类网络号
172.16.10.0/24：172.16.0.0/16这个主类网络的子网
172.0.0.0/8：超网

当我查找127.16.10.1，谁的匹配度最高：172.16.10.1/32

举例：
![2023-03-28-17-22-08](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-28-17-22-08.png)


重点总结：

- 不同的路由前缀（注意路由前缀包含网络号+掩码，缺一不可），在路由表中属于不同的路由。
- 相同的路由前缀，通过不同的协议获取，先比优先级，优选优先级小的，后比cost。
- 这是一般情况，当然有二般情况，这就要看特定的环境和特定的路由协议了。
- 默认采用最长匹配原则，匹配，则转发；无匹配，则找默认路由，默认路由都没有，则丢弃。
- 路由器的行为是逐跳的，到目标网络的沿路径每个路由器都必须有关于目的地的路由。
- 数据是双向的，考虑流量的时候，要关注流量的往返






## 动态路由协议基础


1. 动态路由协议的分类

根据作用的范围，路由协议可分为：

- 内部网关协议（Interior Gateway Protocol，简称IGP）：在一个自治系统内部运行
- 外部网关协议（Exterior Gateway Protocol，简称EGP）：运行于不同自治系统之间

所谓的AS自治系统指的就是，一个独立自治的、自我管理的路由选择域

![](2023-03-28-17-30-49.png)![2023-03-28-17-30-49](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-28-17-30-49.png)

根据使用的算法，路由协议可分为：

- 距离矢量协议（Distance-Vector）：包括RIP和BGP。其中，BGP也被称为路径矢量协议（Path-Vector）
- 链路状态协议（Link-State）：包括OSPF和IS-IS

![2023-03-28-17-30-54](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-28-17-30-54.png)



2. 距离矢量路由协议

![2023-03-29-09-13-57](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-29-09-13-57.png)

使用距离矢量路由协议的路由器并不了解网络的拓扑。该路由器只知道：

- 自身与目的网络之间的距离
- 应该往哪个方向或使用哪个接口转发数据包

实际上，运行距离矢量路由协议的路由器，是将自己的整张路由表更新给直连的其他路由器，彼此之间都进行更新，而路由器也会从其他直连路由器收到他们发来的路由更新，于是就进行一系列的路由收发行为

- RIP


3. 链路状态路由协议

- 距离矢量路由协议，由于路由器并不了解整个拓扑结构，这很容易在特定情况下产生诸如路由环路之类的问题
- 链路状态路由协议则更新的不再是路由表或路由条目，而是对链路（接口）的描述等，通过链路状态信息的泛洪，路由器搜集这些**链路状态信息**并装载进链路状态数据库，随后运行特定的算法计算出一个无环的拓扑
- 因此运行链路状态路由协议的路由器是知晓网络的拓扑结构的

![2023-03-29-09-18-12](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-29-09-18-12.png)

- OSPF
- ISIS



## RIP 基础


1. RIP 的更新过程

- 路由器初始启动

![2023-03-29-09-31-10](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-29-09-31-10.png)


- RIP初次交换路由信息
  - ABC都把自己的路由表广播出去
  - 比如 A 收到 B 传过来的路由表，发现 10.0.3.0 自己没有，就学习过来，同时在为这条路由关联一个度量值：1跳，所谓1跳的意思是，A要到达10.0.3.0这个网络，需要经过B这个路由器
  - RIP通过跳数作为路由的度量值

![2023-03-29-09-33-36](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-29-09-33-36.png)


- 路由收敛完成
  - 继续更新，A就能收到B更新的内容
  - 比如 A就能学习到B更新过来的10.0.4.0路由，跳数为2跳![](2023-03-29-09-33-54.png)![2023-03-29-09-33-54](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-29-09-33-54.png)


路由器收敛完成的标志：

- 当所有路由表包含相同网络可达性信息
- 网络（路由）进入一个稳态


路由器继续交换路由信息：

- 当无新路由信息被更新时收敛结束
- 网络在达到收敛前无法完全正常工作



2. RIP 概述


- RIP（Routing　Information　Protocols，路由信息协议）是历史悠久的内部网关协议，适用于小型网络，是典型的距离矢量协议；
- RIP基于UDP，端口520；
- 在我司设备上路由优先级为100；
- 定期更新整张路由表；依照传闻；距离矢量路由协议并不了解网络拓扑；
- 有三个版本RIPv1、RIPv2和RIPng，RIPng是为IPv6开发的
  - V2在V1的基础上做了如下改进：
    - 增加外部路由标记
    - 增加VLSM支持
    - 组播发送RIP消息：224.0.0.9
    - 支持认证
    - 增加下一跳字段


3. RIP 的 Metric 度量值

- 跳数是并不合理的

![2023-03-29-09-38-26](../2023-03-29-09-38-26.png)


4. RIP 的防环机制

![2023-03-29-09-50-27](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-29-09-50-27.png)

![2023-03-29-09-50-33](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-29-09-50-33.png)

![2023-03-29-09-50-39](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-29-09-50-39.png)

10.0.4.0路由继续在网络中随着更新周期的到来不断的被更新来更新去，然而事实上，10.0.4.0网络早就不存在了，这时候如果网络中有任何一个地方发送数据到10.0.4.0网络，这个数据将在网络中不断的打转，直到TTL递减为0。这就是环路

避免环路的机制：

- 定义最大度量以防止计数至无穷大
- 水平分割
- 路由中毒
- 毒性逆转
- 抑制计时器
- 触发更新


1）定义最大度量以防止计数至无穷大

- RIP定义了一个最大跳数，15跳，当一条路由跳数为16跳时，这条路由被视为不可达，因此这就避免了路由被无休止的传递

2）水平分割规则

- 当一台路由器，从一个接口收到一条路由更新，这台路由器将不再把这条路由从该接口再更新回去，这就是水平分割规则
- RIP的环路避免很大程度上依赖于该规则

3）毒性路由

- 路由中毒机制，上图中，C路由器一旦发现10.0.4.0的直连网络发生故障，它将立即发送一个路由更新，该更新包含10.0.4.0路由同时将跳数设置为16跳，这样其他路由器将接收这个路由更新并将故障路由从路由表中擦去

![2023-03-29-10-19-27](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-29-10-19-27.png)



## OSPF基础


1. OSPF概述

1）LSAs的泛洪

![2023-03-29-10-29-33](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-29-10-29-33.png)

- LSA（链路状态通告）：每台路由器都产生一个描述自己直连接口状态（包括接口的开销、与邻居路由器之间的关系等）的通告，更通俗点的讲法是，每台路由器都产生一个通告，这个通告描述它自家门口的情况
- 运行链路状态路由协议的路由器之间首先会建立一个协议的邻居关系。之后彼此之间开始交互LSA


2）LSDB的组建

![2023-03-29-10-33-04](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-29-10-33-04.png)

- 每台路由器都会产生LSAs，路由器将搜集到的网络中的LSAs放入自己的LSDB（链路状态数据库），有了LSDB，路由器也就清楚了全网的拓扑

3）SPF计算

![2023-03-29-10-35-54](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-29-10-35-54.png)

- 每台路由器基于LSDB，使用SPF（最短路径算法）进行计算
- SPF是OSPF路由协议的一个核心算法，用来在一个复杂的网络中做出路由优选的决策
- 经过SPF算法的计算后，每台路由器都计算出一棵以自己为根的、无环的、拥有最短路径的“树”。有了这棵“树”，事实上路由器就已经知道了到达网络各个角落的最优路径


4）维护路由表

![2023-03-29-10-38-31](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-29-10-38-31.png)

- 最后，路由器将计算出来的最优路径，加载进自己的路由表


概述：

- OSPF：Open Shortest Path First，**开放最短路径优先协议**，是一种链路状态路由协议，在RFC 2328中描述。OSPF中的字母O意为open，也就是开放、公有，任何标准化的设备厂商都能够支持OSPF。
- OSPF是一种使用相当广泛的IGP协议，深入掌握OSPF非常有必要。
- 与距离矢量路由协议直接交互路由器的路由表不同，OSPF作为链路状态路由协议，路由器之间交互的是**LSA**（链路状态通告），路由器将网络中泛洪的LSA搜集到自己的**LSDB**（链路状态数据库）中，这有助于OSPF理解整张网络拓扑，并在此基础上通过**SPF最短路径算法**计算出以自己为根的、到达网络各个角落的、无环的树，最终，路由器将计算出来的路由装载进路由表中。
- 在我司设备上，OSPF的协议优先级：10
- OSPF采用SPF算法计算达到目的地的最短路径：
  - 什么叫链路(LINK) = 路由器接口
  - 什么叫状态(State) = 描述接口以及其与邻居路由器之间的关系


2. OSPF基本概念

1）COST 开销

- OSPF使用cost“开销”作为路由度量值
- 每一个激活OSPF的接口都有一个cost值。OSPF接口 cost=100M /接口带宽，其中100M为OSPF的参考带宽（reference-bandwidth）
- 一条OSPF路由的cost由该路由从路由的起源一路到达本地的所有入接口cost值的总和

![2023-03-29-11-08-08](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-29-11-08-08.png)


2）Router-ID

- OSPF Router-ID用于在OSPF domain中唯一地表示一台OSPF路由器，从OSPF网络设计的角度，我们要求全OSPF域内，禁止出现两台路由器拥有相同的OSPFRouterID
- OSPF Router-ID的设定可以通过手工配置的方式，或者通过协议自动选取的方式。当然，在实际网络部署中，强烈建议手工配置OSPF的Router-ID，因为这关系到协议的稳定
- 在路由器运行了OSPF并确定了Router-ID之后，如果该Router-ID对应的接口DOWN掉或者接口消失（例如undo interface loopback0）或出现一个更大的IP，OSPF仍然保持原Router-ID（也就是说，Router-ID值是非抢占的，稳定第一），即使此时reset ospf process重启OSPF进程，Router-ID也不会发生改变；除非重新手工配置Router-ID（OSPF进程下手工敲router-id xxx），并且重启OSPF进程方可


3）报文类型

OSPF一共有五种报文，各有各的用途：

- Hello建立和维护OSPF邻居关系
- DBD链路状态数据库描述信息（描述LSDB中LSA头部信息）
- LSR链路状态请求，用于向OSPF邻居请求链路状态信息
- LSU链路状态更新（包含一条或多条LSA）
- LSAck对LSU中的LSA进行确认


4）OSPF的三张表

- 邻居表（peer table）：
  OSPF是一种可靠的路由协议，要求在路由器之间传递链路状态通告之前，需先建立OSPF邻居关系，hello报文用于发现直连链路上的其他OSPF路由器，再经过一系列的OSPF消息交互最终建立起全毗邻的邻居关系，其中两者之间需要经历几个邻居关系状态，这也是一个重要的知识点。路由器在各个激活的OSPF的接口上维护的邻居都列在邻居表中，通过观察邻居表，能够进一步了解OSPF路由器之间的邻居状态。

 - 链路状态数据库（link-state database）
   OSPF用LSA（link state Advertisement 链路状态通告）来描述网络拓扑信息，然后OSPF路由器用链路状态数据库来存储网络的这些LSA。OSPF将自己产生的以及邻居通告的LSA搜集并存储在链路状态数据库LSDB中。掌握LSDB的查看以及对LSA的深入分析才能够深入理解OSPF。

 - OSPF路由表（routing table）：
   对链路状态数据库进行SPF（Dijkstra）计算，而得出的OSPF路由表



5）OSPF邻居关系建立过程

![2023-03-29-11-12-57](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-29-11-12-57.png)



6）OSPF网络类型

- OSPF支持的网络类型
- 点到点网络
- 广播型多路访问网络
- 非广播型多路访问（NBMA）网路
- P2MP网络

常见链路层协议对应的默认网络类型:

![2023-03-29-11-17-07](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-29-11-17-07.png)


7）DR、BDR

![2023-03-29-11-20-42](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-29-11-20-42.png)

- 为减小多路访问网络中的 OSPF 流量，OSPF 会在每一个MA网络（多路访问网络）选举一个指定路由器 (DR) 和一个备用指定路由器 (BDR)
- DR选举规则：最高OSPF接口优先级拥有者被选作DR，如果优先级相等（默认为1），具有最高的OSPF Router-ID的路由器被选举成DR，并且DR具有非抢占性，也就是说如果该MA网络中，已经选举完成、并且选举出了一个DR，那么后续即使有新的、更高优先级的设备加入，也不会影响DR的选举，除非DR挂掉
- **指定路由器 (DR)**：DR 负责**侦听多路访问网络中的拓扑变更信息**并将变更信息**通知给其他路由器**，同时负责代表该MA网络发送LSA类型2。MA网络中，**所有的OSPF路由器都与DR建立全毗邻的OSPF邻接关系**
- **备用指定路由器 (BDR)**：BDR 会**监控 DR 的状态**，并在当前 DR 发生故障时接替其角色
- 注意OSPF为“接口敏感型协议”，DR 及 BDR 的身份状态是基于 OSPF 接口的，所以如果我们说：“这台路由器是 DR”实际上这种说法是不严谨的，严格的说，应该是：“这台路由器的这个接口，在这个 MA 网络上是 DR”
- MA网络中，所有的 DRother 路由器均只与 DR 和 BDR 建立全毗邻的邻接关系，DRother 间不建立全毗邻邻接关系，如此一来，该多路访问网络中设备需要维护的OSPF邻居关系大幅减小：M= (n-2)×2+1，LSA 的泛洪问题也可以得到一定的缓解
- 路由器的接口如果网络类型为广播多路访问或者非广播多路访问型，那么都会进行 DR/BDR 的选举。所以我们看，OSPF 接口网络类型的不同，OSPF 的操作是有所不同的。在 P2P 或者 P2MP 类型的接口上，就不选举 DR\BDR


MA网络中，有了DR、BDR的存在后，LSA的泛洪：

![2023-03-29-11-24-43](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-29-11-24-43.png)

- 假设网络已经完成了OSPF收敛，现在突然R3下挂的一个网络发生了故障
- 路由器R3用224.0.0.6通知DR及BDR
- DR、BDR监听224.0.0.6这一组播地址
- DR向组播地址224.0.0.5发送更新以通知其它路由器
- 所有的OSPF路由器监听224.0.0.5这一组播地址
- 路由器收到包含变化后的LSA的LSU后，更新自己的LSDB，过一段时间(SPF延迟)，对更新的链路状态数据库执行SPF算法，必要时更新路由表。

  - OSPF使用两个well-known的组播地址：224.0.0.5及224.0.0.6
  - 所有的OSPF路由器（的接口）都会侦听发向224.0.0.5这个组播地址的报文，所有DR/BDR都会侦听224.0.0.6



3. OSPF 区域（area）的概念

1）单区域存在的问题

设想一下，如果OSPF没有区域的概念，或者整个OSPF网络就是一个区域，那么会有什么问题？首先LSA泛洪严重，OSPF路由器的负担很大，因为OSPF要求区域内的所有路由器，LSDB必须统一，这样以便计算出一个统一的、无环的拓扑。

- 区域内部动荡会引起全网路由器的SPF计算
- LSDB庞大，资源消耗过多，设备性能下降，影响数据转发
- 每台路由器都需要维护的路由表越来越大，单区域内路由无法汇总


2）OSPF多区域

![2023-03-29-11-39-59](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-29-11-39-59.png)

基于上述原因，OSPF设计了区域area的概念

- 多区域的设计减少了LSA洪泛的范围，有效地把拓扑变化控制在区域内，达到网络优化的目的
- 在区域边界可以做路由汇总，减小了路由表
- 充分利用OSPF特殊区域的特性，进一步减少LSA泛洪，从而优化路由
- 多区域提高了网络的扩展性，有利于组建大规模的网络



3）OSPF区域中的骨干区域area0

![2023-03-29-11-40-33](../2023-03-29-11-40-33.png)

- 在部署OSPF时，要求全OSPF域，必须有且只能有一个area0
- Area 0为骨干区域，骨干区域负责在非骨干区域之间发布由区域边界路由器汇总的路由信息（并非详细的链路状态信息）
- 为避免区域间路由环路，非骨干区域之间不允许直接相互发布区域间路由。因此，所有区域边界路由器都至少有一个接口属于Area 0，即每个区域都必须连接到骨干区域


4）OSPF路由器的角色

![2023-03-29-11-41-26](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-03-29-11-41-26.png)


OSPF路由器的角色：

- 区域内路由器Internal Router
- 区域边界路由器Area Border Router
- 骨干路由器Backbone Router
- AS边界路由器AS Boundary Router


## BGP 协议

https://blog.csdn.net/keith6785753/article/details/107088632?spm=1001.2101.3001.6650.12&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-12-107088632-blog-115476061.235%5Ev31%5Epc_relevant_default_base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-12-107088632-blog-115476061.235%5Ev31%5Epc_relevant_default_base&utm_relevant_index=17


## VPN


## Overlay / Underlay


- Underlay
  - Underlay 网络是由各类物理设备构成，通过使用路由协议保证其设备之间的IP连通性的承载网络
  - 可以理解为**物理网络**
- Overlay
  - Overlay 网络是通过网络虚拟化技术，在同一张Underlay网络上构建出的一张或者多张虚拟的逻辑网络
  - 不同的Overlay网络虽然共享Underlay网络中的设备和线路，但是Overlay网络中的业务与Underlay网络中的物理组网和互联技术相互解耦
  - 可以理解为**逻辑网络**



### Underlay

- Underlay 网络是负责传递数据包的物理网络
- 在 Underlay 网络中，互联的设备可以是各类型交换机、路由器、负载均衡设备、防火墙等
- 网络的各个设备之间必须通过路由协议来确保之间 IP 的连通性
- Underlay 协议：
  - BGP
  - OSPF
  - IS-IS
  - EIGRP

- Underlay网络可以是二层也可以是三层网络
  - 二层网络通常应用于以太网，通过VLAN进行划分
  - 三层网络的典型应用就是互联网
    - 其在同一个自治域使用OSPF、IS-IS等协议进行路由控制，在各个自治域之间则采用BGP等协议进行路由传递与互联
  - 随着技术的进步，也出现了使用MPLS这种介于二三层的WAN技术搭建的Underlay网络
- 产生了问题：
  - 由于硬件根据目的IP地址进行数据包的转发，所以传输的路径依赖十分严重
  - 新增或变更业务需要对现有底层网络连接进行修改，重新配置耗时严重
  - 互联网不能保证私密通信的安全要求
  - 网络切片和网络分段实现复杂，无法做到网络资源的按需分配
  - 多路径转发繁琐，无法融合多个底层网络来实现负载均衡





### Overlay


- Overlay 是使用网络虚拟化在物理基础设施之上建立连接的逻辑网络
- 相互连接的Overlay设备之间建立隧道，数据包准备传输出去时，设备为数据包添加新的IP头部和隧道头部，并且被屏蔽掉内层的IP头部，数据包根据新的IP头部进行转发。当数据包传递到另一个设备后，外部的IP报头和隧道头将被丢弃，得到原始的数据包，在这个过程中Overlay网络并不感知Underlay网络
- Overlay 协议：
  - VXLAN
  - NVGRE
  - GRE
  - OTV
  - OMP
  - mVPN
- Overlay网络使用隧道技术，可以灵活选择不同的底层链路，使用多种方式保证流量的稳定传输
  - Overlay网络可以按照需求建立不同的虚拟拓扑组网，无需对底层网络作出修改
  - 通过加密手段可以解决保护私密流量在互联网上的通信
  - 支持网络切片与网络分段。将不同的业务分割开来，可以实现网络资源的最优分配
  - 支持多路径转发。在Overlay网络中，流量从源传输到目的可通过多条路径，从而实现负载分担，最大化利用线路的带宽


应用：

- 数据中心的Overlay网络
  - ![2023-04-21-19-31-57](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-04-21-19-31-57.png)
- SD-WAN中的Overlay网络
  - SD-WAN的Underlay网络基于广域网，通过混合链路的方式达成总部站点、分支站点、云网站点之间的互联
  - ![2023-04-21-19-40-14](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/2023-04-21-19-40-14.png)
  - SD-WAN 的网络主要由 CPE 设备构成，其中 CPE 又分为 Edge 和 GW 两种类型
    - CPE：Customer-Premises Equipment 客户场所设备，指用于访问 Internet 或通常访问提供商网络上的服务的任何连接设备
    - Edge：是 SD-WAN 站点的出口设备
    - GW：是联接 SD-WAN 站点和其他网络（如传统VPN）的网关设备


## NTP



## ACL



